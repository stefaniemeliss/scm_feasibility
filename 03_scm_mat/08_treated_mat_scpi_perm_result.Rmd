---
title: "Power analysis with *scpi* package"
author: "Stefanie Meliss"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen = 999)
# empty work space
rm(list = ls())
gc()

# Set seed
set.seed(202324)

# load libraries
library(kableExtra)
library(dplyr)
library(data.table)
library(ggplot2)
library(scpi)

# create function to source code
source_code <- function(root_dir_name = "code", target_repo = "helper_functions", branch = "main", file_name = "file.R") {
  
  # construct URL
  git_url <- paste0("https://raw.githubusercontent.com/stefaniemeliss/", target_repo, "/", branch, "/", file_name)
  
  # attempt to download from github
  tempp_file <- tempfile(fileext = ".R")
  message <- curl::curl_download(git_url, tempp_file, quiet = F)
  
  if(!grepl("Error", message)) {
    
    # if successful, source file
    source(tempp_file)
    remove(tempp_file)
    
  } else { # load local copy of file
    
    # Get the current working directory
    current_dir <- getwd()
    
    # Split the current directory into its components
    dir_components <- strsplit(current_dir, "/")[[1]]
    
    # Identify the root directory dynamically based on the provided root directory name
    root_index <- which(dir_components == root_dir_name)
    if (length(root_index) == 0) {
      stop(paste("Root directory", root_dir_name, "not found in the current path"))
    }
    root_dir <- do.call(file.path, as.list(dir_components[1:root_index]))
    
    # Identify the subdirectory one level below the root and construct its absolute path
    project_repo <- dir_components[root_index + 1]
    dir <- file.path(root_dir, project_repo)
    
    if (target_repo != project_repo) {
      dir <- gsub(project_repo, target_repo, dir) 
    }
    
    # Construct the full file path
    file_path <- file.path(dir, file_name)
    
    # Print the directory and file path for debugging
    print(paste("Directory:", dir))
    print(paste("File path:", file_path))
    
    # Source the file into the parent frame
    source(file_path, local = parent.frame())
  }
}

# source functions
source_code(target_repo = "scm_feasibility", file_name = "functions.R")

# Define the base directory
dir <- get_directory()
dir_data <- file.path(dir, "data")
dir_misc <- file.path(dir, "misc")

# get file stem name
file_stem <- get_file_stem()

# copy data #
file.copy(
  file.path(gsub("scm_feasibility", "edu_stats", dir_data), "data_swf.csv"), dir_data, overwrite = T)
file.copy(
  file.path(gsub("scm_feasibility", "edu_stats", dir_data), "data_pupils.csv"), dir_data, overwrite = T)
file.copy(
  file.path(gsub("scm_feasibility", "edu_stats", dir_data), "data_establishments_search.csv"), dir_data, overwrite = T)
file.copy(
  file.path(gsub("scm_feasibility", "edu_stats", dir_data), "data_establishments_groups.csv"), dir_data, overwrite = T)

# load data #

swf <- fread(file.path(dir_data, "data_swf.csv"))
pup <- fread(file.path(dir_data, "data_pupils.csv"))
est <- fread(file.path(dir_data, "data_establishments_search.csv"), na.strings = "")
groups <- fread(file.path(dir_data, "data_establishments_groups.csv"), na.strings = "")

uid_treated <- 2939

# Dixon schools
dix <- groups %>% filter(group_uid == uid_treated)

# get establishment data from treated schools
list_laestab <- c(dix$laestab)

# create lookup 
lookup <- data.frame(time_period = sort(unique(swf$time_period)))
lookup$time_period_str <- insert_slash(lookup$time_period)
lookup$time_period <- as.numeric(substr(lookup$time_period, 0, 4))


# Create the data frame
lookup <- data.frame(time_period = c(2010:2026), 
                     time_period_str = c("2010/11", "2011/12", "2012/13", "2013/14", "2014/15", "2015/16", 
                                         "2016/17", "2017/18", "2018/19", "2019/20", "2020/21", "2021/22", 
                                         "2022/23", "2023/24", "2024/25", "2025/26", "2026/27"))


```


```{r nat, include=F}
# Copy data files from the source directory to the target directory
file.copy(
  file.path(gsub("scm_feasibility", "edu_stats", dir_data), "data_swf.csv"),
  dir_data,
  overwrite = TRUE
)

# Load data from CSV files into data tables
swf <- fread(file = file.path(dir_data, "data_swf.csv"))
dv <- "pupil_to_qual_teacher_ratio"

# Remove rows for years for which there is no outcome data, 
# and add observation count and count of outliers per school

# Perform the data transformation and filtering
z <- swf %>%
  # Select relevant columns from the data frame
  select(time_period, laestab, school, urn, pupil_to_qual_teacher_ratio) %>%
  # Filter out rows where the variable of interest (dv) is NA
  filter(!is.na(get(dv))) %>%
  # Group the data by school identifier
  group_by(laestab) %>%
  # Add new columns to count non-NA observations and outliers within each group
  mutate(
    obs_count_dv = sum(!is.na(get(dv))), # Count the number of non-NA observations for dv
    outliers_dv = is_outlier_3sd(get(dv)),
    count_outliers_dv = sum(is_outlier_3sd(get(dv))) # Count the number of outliers for dv
  ) %>%
  # Remove the grouping to perform subsequent operations on the entire data frame
  ungroup() %>%
  # Filter out groups (schools) with fewer than 6 observations for dv
  filter(obs_count_dv >= 6) %>%
  # Filter out groups (schools) that have any outliers within their timeseries for dv
  filter(count_outliers_dv == 0) %>%
  # Select the columns to keep in the final output
  select(time_period, laestab, school, pupil_to_qual_teacher_ratio) %>%
  # Convert the resulting tibble back to a base R data frame
  as.data.frame()


# Remove outliers from data - 1st run #

z <- z %>%
  # Add a new column to identify outliers based on the 3-sigma rule
  mutate(
    outlier_dv = is_outlier_3sd(get(dv))
  ) %>%
  # Group the data by the 'laestab' column (likely a school identifier)
  group_by(laestab) %>%
  # Add a new column to count the number of outliers within each group
  mutate(
    count_outliers_dv = sum(outlier_dv)
  ) %>%
  # Remove the grouping to perform subsequent operations on the entire data frame
  ungroup() %>%
  # Filter out groups (schools) that have any outliers within their timeseries for dv
  filter(count_outliers_dv == 0) %>%
  # remove the temporary columns 'outlier_dv' and 'count_outliers_dv'
  # select(-outlier_dv, -count_outliers_dv) %>%
  # Convert the resulting tibble back to a base R data frame
  as.data.frame()

# Remove outliers from data - 2nd run #
# second run applied because first run resulted in such high SD that the lower bound was negative - which is implausible as a cut-off given that the PTR values are positive 

z <- z %>%
  # Add a new column to identify outliers based on the 3-sigma rule
  mutate(
    outlier_dv = is_outlier_3sd(get(dv))
  ) %>%
  # Group the data by the 'laestab' column (likely a school identifier)
  group_by(laestab) %>%
  # Add a new column to count the number of outliers within each group
  mutate(
    count_outliers_dv = sum(outlier_dv)
  ) %>%
  # Remove the grouping to perform subsequent operations on the entire data frame
  ungroup() %>%
  # Filter out groups (schools) that have any outliers within their timeseries for dv
  filter(count_outliers_dv == 0) %>%
  # remove the temporary columns 'outlier_dv' and 'count_outliers_dv'
  select(-outlier_dv, -count_outliers_dv) %>%
  # Convert the resulting tibble back to a base R data frame
  as.data.frame()


# compute timeseries descriptives
desc <- z %>%
  group_by(laestab) %>%
  summarise(
    mean = mean(pupil_to_qual_teacher_ratio, na.rm = T),
    sd = sd(pupil_to_qual_teacher_ratio, na.rm = T),
    var = var(pupil_to_qual_teacher_ratio, na.rm = T),
    min = min(pupil_to_qual_teacher_ratio, na.rm = T),
    max = max(pupil_to_qual_teacher_ratio, na.rm = T),
    n = n()
  )

# Calculate pooled variance
# Sum the product of the number of observations minus one and the variance for each school, then divide by the total number of observations minus one.
pooled_variance <- sum((desc$n - 1) * desc$var) / sum(desc$n - 1)
pooled_sd <- sqrt(pooled_variance)

# Compute the weighted mean
# Multiply each school's mean by the number of observations for that school, sum these products, and then divide by the total number of observations.
pooled_mean <- sum(desc$n * desc$mean) / sum(desc$n)

# extract range as mean +/- 3SD -> for plotting
bound_lo <- pooled_mean - 3*pooled_sd
bound_up <- pooled_mean + 3*pooled_sd
```

```{r ratio, include=F}
# Number of pupils (constant)
num_pupils <- 1000
num_teach <- 62

# Starting ratio
starting_ratio <- num_pupils/num_teach

# Create a sequence of ratios from starting_ratio, incrementing by 0.2
ratios <- seq(starting_ratio - 3, starting_ratio + 3, by = 0.5)

# Function to calculate number of teachers based on pupil-to-teacher ratio
calculate_teachers <- function(pupil_teacher_ratio, num_pupils) {
  num_teachers <- num_pupils / pupil_teacher_ratio
  return(num_teachers)
}

# Calculate number of teachers for each ratio
teachers_needed <- sapply(ratios, calculate_teachers, num_pupils)

# Create a data frame for better readability
results <- data.frame(
  ratio = ratios,
  teacher_fte = teachers_needed
)
results$change_ratio <- results$ratio - starting_ratio
results$change_fte <- results$teacher_fte - num_teach

# add to markdown
kbl(results, digits = 3, row.names = F, caption = "Mapping between changes in ratio and teacher FTE") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), fixed_thead = T) %>%
  add_footnote("We here assume a constant number of pupil FTE of 1000.") %>%
  print()

# Function to calculate change in number of teachers based on change in ratio
calculate_change_in_teachers <- function(starting_ratio, change_in_ratio, num_pupils) {
  new_ratio <- starting_ratio + change_in_ratio
  initial_teachers <- num_pupils / starting_ratio
  new_teachers <- num_pupils / new_ratio
  change_in_teachers <- new_teachers - initial_teachers
  return(change_in_teachers)
}


# Example initial ratio and change in ratio
change_in_ratio <- -0.2

# Calculate change in number of teachers
change_in_teachers <- calculate_change_in_teachers(starting_ratio, change_in_ratio, num_pupils)
```


```{r est, eval=FALSE, include=F}
### ---- prepare data ---- ###

# load in simulated data #
# determine input filename
file_name <- file.path(dir, "03_scm_mat", "interim", paste0("06_treated_mat_simulate_data_", tolower(phase), "_it_", sprintf("%03d", ii), ".csv"))

# read in results
df_sim_raw <- read.csv(file_name)
lookup <- unique(df_sim_raw[, c("time_period", "time_period_str")])

# Define timeseries
period.simulated <- unique(df_sim_raw$time_period[is.na(df_sim_raw$pupil_to_qual_teacher_ratio)]) # identify simulated years
period.post <- period.simulated # Simulated post-treatment period
period.avail <- sort(unique(df_sim_raw$time_period))
period.pre <- setdiff(period.avail, period.post) # Pre-treatment period

# compute MAT level average
# df_avg <- df_sim_int %>% # APPLY EFFECTS AT SCHOOL LEVEL
df_avg_raw <- df_sim_raw %>% # APPLY EFFECTS AT MAT LEVEL
  group_by(group_uid, time_period)  %>%
  summarise(
    !!sym(dv) := mean(!!sym(dv)),
    !!sym(var_teach) := mean(!!sym(var_teach)),
    !!sym(var_pup) := mean(!!sym(var_pup)),
    #sim = mean(sim),
    n = n(), .groups = "drop"
  ) %>% 
  ungroup() %>%
  left_join(lookup, .) %>%
  mutate(status = ifelse(group_uid == uid_treated, id_group, "Donor MATs")) %>%
  arrange(group_uid, time_period) %>%
  as.data.frame()


# determine ids of control schools
id_cont <- unique(MATs$group_uid[MATs$group_uid != uid_treated])

unit.tr <- uid_treated # Treated unit (in terms of id.var)
unit.co <- id_cont # Donors pool

# determine features and covariate adjustment settings
features <- unlist(strsplit(params$features, ", "))
if(!is.na(params$cov.adj)){
  cov.adj <- case_match(params$cov.adj, "constant" ~ list(c("constant")), "trend" ~ list(c("trend")), "constant, trend" ~ list(c("constant", "trend")))
} else { 
  cov.adj <- NULL
}

####################################
### Data preparation
scdata.out <- scdata(df = df_avg_raw, 
                     id.var = id.var, 
                     time.var = time.var,
                     outcome.var = outcome.var,
                     period.pre = period.pre,
                     period.post = period.post,
                     unit.tr = unit.tr,
                     unit.co = unit.co,
                     features = features,
                     cov.adj = cov.adj)

####################################
### SC - point estimation with simplex
scest.out <- scest(data = scdata.out, 
                   w.constr = w.constr
)

```

```{r res, eval=FALSE, include=F}
#### SC - evaluate results ####
summarise_scest(scest.out, id_treated = uid_treated, id_name = id_group, cv = F)

print(scplot(result = scest.out, plot.range = period.pre,
             label.xy = list(x.lab = "Start of academic year", y.lab = "Ratio of pupils to qualified teachers")))
cat("\n\n")
#### EXTRACT DATA #####

# Access and examine the raw features for the treated unit (A)
# Each row represents a different feature-year combination for the treated unit.
treated_features <- scest.out$data$A

# Access and examine the raw features for the control units (B)
# Each row represents a different feature-year combination for the control units, and each column represents a different control unit.
control_features <- scest.out$data$B

# Access and examine the synthetic control weights (w)
# Each element represents the weight assigned to a corresponding control unit in constructing the synthetic control.
weights <- scest.out$est.results$w

# Compute the synthetic control's pre-treatment feature values
synthetic_features_raw <- control_features %*% weights # this is a hypothetical scenario where we only take the weights into consideration

# Compare the treated and synthetic control feature values
comparison_raw <- cbind(treated_features, synthetic_features_raw)
colnames(comparison_raw) <- c(id_group, "Synthetic MAT")
comparison_raw <- as.data.frame(comparison_raw)
comparison_raw$Variable <- row.names(comparison_raw)
comparison_raw$Year <- as.numeric(stringi::stri_extract_last_regex(comparison_raw$Variable, "\\d{4}"))
comparison_raw$Variable <- gsub("[[:digit:]]+", "", comparison_raw$Variable)
comparison_raw$Variable <- gsub(".", "", comparison_raw$Variable, fixed = T)

# Make data long for plotting
comparison_raw <- reshape2::melt(comparison_raw, id.var = c("Variable", "Year"), value.name = "Value", variable.name = "Unit")
comparison_raw$Variable <- factor(comparison_raw$Variable,
                                  levels = c("pupil_to_qual_teacher_ratio", "fte_avg_age", "pnpupfsm_e"),
                                  labels = c("Outcome", "Teacher age", "% pupils FSM"))

# Plot the feature values
cols <- c(navy, coral)
names(cols) <- c("Synthetic MAT", id_group)

print(ggplot(data = comparison_raw, aes(x = Year, y = Value, group = Unit)) +
        geom_line(data = comparison_raw[comparison_raw$Unit == id_group, ], aes(col = paste(id_group))) +
        geom_point(data = comparison_raw[comparison_raw$Unit == id_group, ], aes(col = paste(id_group))) +
        geom_line(data = comparison_raw[comparison_raw$Unit == "Synthetic MAT", ], aes(col = "Synthetic MAT")) +
        geom_point(data = comparison_raw[comparison_raw$Unit == "Synthetic MAT", ], aes(col = "Synthetic MAT")) +
        facet_wrap(vars(Variable), ncol = 1, scales = "free_y") +
        labs(title = "Feature timeseries without covariate adjustment",
             x = "Academic year",
             y = "Reported value") +
        ambition_theme +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
              legend.title = element_blank(),
              strip.text = element_text(size = 10)) +
        scale_color_manual(
          breaks=c(id_group, "Synthetic MAT"),
          values=cols) +
        scale_x_continuous(breaks = lookup$time_period, labels = lookup$time_period_str)
)

if (!is.null(scest.out$data$C)) {
  
  # Access and examine the raw features for the control units (B) **and the covariates (C)**
  # Each row represents a different feature-year combination for the control units, and each column represents a different control unit.
  control_features <- cbind(scest.out$data$B, scdata.out$C)
  
  # Access and examine matrix *b*, containing the synthetic control weights (w) and values of the covariate adjustment (r)
  b <- scest.out$est.results$b # a matrix containing w (a matrix containing the estimated weights of the donors) and r (a matrix containing the values of the covariates used for adjustment)
  
  # Compute the synthetic control's pre-treatment feature values
  synthetic_features_adjusted <- control_features %*% b # this is how scest.out$est.results$A.hat is internally computed
  
  # Compare the treated and synthetic control feature values
  comparison_adjusted <- cbind(treated_features, synthetic_features_adjusted)
  colnames(comparison_adjusted) <- c(id_group, "Synthetic MAT")
  comparison_adjusted <- as.data.frame(comparison_adjusted)
  comparison_adjusted$Variable <- row.names(comparison_adjusted)
  comparison_adjusted$Year <- as.numeric(stringi::stri_extract_last_regex(comparison_adjusted$Variable, "\\d{4}"))
  comparison_adjusted$Variable <- gsub("[[:digit:]]+", "", comparison_adjusted$Variable)
  comparison_adjusted$Variable <- gsub(".", "", comparison_adjusted$Variable, fixed = T)
  
  # Make data long for plotting
  comparison_adjusted <- reshape2::melt(comparison_adjusted, id.var = c("Variable", "Year"), value.name = "Value", variable.name = "Unit")
  comparison_adjusted$Variable <- factor(comparison_adjusted$Variable,
                                         levels = c("pupil_to_qual_teacher_ratio", "fte_avg_age", "pnpupfsm_e"),
                                         labels = c("Outcome", "Teacher age", "% pupils FSM"))
  
  # Plot the feature values
  print(ggplot(data = comparison_adjusted, aes(x = Year, y = Value, group = Unit)) +
          geom_line(data = comparison_adjusted[comparison_adjusted$Unit == id_group, ], aes(col = paste(id_group))) +
          geom_point(data = comparison_adjusted[comparison_adjusted$Unit == id_group, ], aes(col = paste(id_group))) +
          geom_line(data = comparison_adjusted[comparison_adjusted$Unit == "Synthetic MAT", ], aes(col = "Synthetic MAT")) +
          geom_point(data = comparison_adjusted[comparison_adjusted$Unit == "Synthetic MAT", ], aes(col = "Synthetic MAT")) +
          facet_wrap(vars(Variable), ncol = 1, scales = "free_y") +
          labs(title = "Feature timeseries with covariate adjustment",
               x = "Academic year",
               y = "Reported value") +
          ambition_theme +
          theme(axis.text.x = element_text(angle = 45, hjust = 1),
                legend.title = element_blank(),
                strip.text = element_text(size = 10)) +
          scale_color_manual(
            breaks=c(id_group, "Synthetic MAT"),
            values=cols) +
          scale_x_continuous(breaks = lookup$time_period, labels = lookup$time_period_str)
  )
  
}
cat("\n\n")



```


```{r proc grid, eval = F, include=F}
# declare file name
file_name <- file.path(dir, "03_scm_mat", "interim", paste0("03_treated_mat_scpi_cv_", tolower(phase), "_results.csv"))

# read in results
results <- read.csv(file_name)

#### process data grid search ####

# copy data for editing
results_fit <- results

# --- create new vars for facets --- #

# timeseries processing options #
# min years per school
results_fit$min.years.obs <- paste0(results_fit$min.years.obs, "Y")
results_fit$min.years.obs <- factor(results_fit$min.years.obs)
# min schools per year
results_fit$min.schools.per.timeperiod <- paste0(results_fit$min.schools.per.timeperiod, "S/Y")
results_fit$min.schools.per.timeperiod <- factor(results_fit$min.schools.per.timeperiod)
# min schools per mat
results_fit$min.schools.per.mat <- paste0(results_fit$min.schools.per.mat, "S")
results_fit$min.schools.per.mat <- factor(results_fit$min.schools.per.mat)

# did we remove outliers
results_fit$excl.out <- ifelse(results_fit$excl.outlier, "excl. out", "incl. out")

# donor pool filtering options # 

# which region was used for filtering
results_fit$region <- ifelse(grepl("North West", results_fit$regions), "YS&H + NW", "YS&H")
results_fit$region <- factor(results_fit$region)
# were any MATs excluded?
if (phase == "mixed") {
  results_fit$phase <- ifelse(results_fit$exclude.single.phase, "excl. single phase", "incl. single phase")
  results_fit$phase <- factor(results_fit$phase)
} else {
  results_fit$phase <- "same phase"
  results_fit$phase <- factor(results_fit$phase)
}

# SCM setup options in scpi #

# is DV in features?
results_fit$feat_dv <- ifelse(grepl("ratio", results_fit$features), "incl. DV", "excl. DV")
results_fit$feat_dv <- factor(results_fit$feat_dv)

# covariate adjustment
results_fit$adj <- ifelse(is.na(results_fit$cov.adj), "none", results_fit$cov.adj)
results_fit$adj <- factor(results_fit$adj, levels = c("none", "constant", "trend", "constant, trend"),
                          labels = c("none", "Constant", "Trend", "C + T"))

# which years were used in training
results_fit$min_year <- sapply(results_fit$period.pre, function(x) extract_min_max_years(x)[1])
results_fit$max_year <- sapply(results_fit$period.pre, function(x) extract_min_max_years(x)[2])
results_fit$period.pre <- paste0(results_fit$min_year, ":", results_fit$max_year)
results_fit$period.pre <- factor(results_fit$period.pre)

# which constraints were applied to the weights
results_fit$method <- tstrsplit(results_fit$w.constr, "; ")[[1]]
results_fit$method <- gsub("name = ", "", results_fit$method)
results_fit$method <- factor(results_fit$method, levels = c("simplex", "L1-L2", "lasso", "user provided"))

# compute fit stats
results_fit <- results_fit %>%
  # create one col per rmspe
  mutate(
    sd_all = sd_treated[cross.val == F],
    rmspe_all = rmspe_pre[cross.val == F], 
    rmspe_T = rmspe_pre[cross.val == T], 
    rmspe_V = rmspe_post[cross.val == T],
    .by = it
  ) %>%
  # compute ratios #
  # if ratio is below 1: worse fit in training than in validation data
  # if ratio is above 1: worse fit in training than in validation data
  # if ratio is equal to 1: equal fit in training and validation data
  mutate(ratio = rmspe_V / rmspe_T) %>%
  # remove all CV runs
  filter(cross.val == F)

```


```{r sims, eval=FALSE, include=F}
# compute ratio of post-treatment RMSPE To pre-treatment RMSPE                                                  
rmspe <- function(x){sqrt(mean(x^2))}

# process data from placebo runs #

# determine file pattern - CHANGE
pattern = paste0("07_treated_mat_scpi_perm_", tolower(phase), "_it_", sprintf("%03d", ii))

# list all files
files = sort(list.files(path = file.path(dir, "03_scm_mat", "interim"), pattern = pattern, full.names = T))
files <- files[grepl(sprintf("%.2f", decrease), files)] # focus on this decrease

if (length(files) > 0) {
  
  for (f in 1:length(files)) {
    
    file = files[f]
    
    # read in results
    storegaps <- read.csv(file)
    names(storegaps)[1] <- "time_period"
    names(storegaps) <- gsub("X", "", names(storegaps))
    
    preloss <- apply(storegaps[1:length(period.pre), -1], 2, rmspe)
    postloss <- apply(storegaps[(1+length(period.pre)):(length(period.pre)+length(period.post)), -1], 2, rmspe)
    ratio <- sort(postloss/preloss)
    observed_statistic <- ratio[names(ratio) == uid_treated]
    
    # compute treatment effect
    postgap <- apply(storegaps[(1+length(period.pre)):(length(period.pre)+length(period.post)), -1], 2, mean)
    avg_gap_post <- postgap[names(postgap) == uid_treated]
    
    # combine permutation data into df
    perm_results <- data.frame(laestab = names(preloss),
                               rmspe_pre = preloss,
                               rmspe_post = postloss,
                               ratio = postloss / preloss)
    
    # identify ill-fitting placebo runs
    perm_results$thresh5 <- perm_results$rmspe_pre < perm_results$rmspe_pre[perm_results$laestab == uid_treated] * 5
    n_ill <- sum(perm_results$thresh5 == F)
    cutoff_value <- quantile(perm_results$ratio, 0.95, na.rm = T)
    cutoff_thresh5 <- quantile(perm_results$ratio[perm_results$thresh5 == T], 0.95, na.rm = T)
    
    prob <- sum(perm_results$ratio >= observed_statistic) / length(perm_results$ratio)
    prob_thresh5 <- sum(perm_results$ratio[perm_results$thresh5] >= observed_statistic) / sum(perm_results$thresh5)
    
    sig <- prob < .05
    sig_thresh5 <- prob_thresh5 < .05
    
    # initialise df for results
    sim <- data.frame(
      group_uid = uid_treated,
      mat = id_group,
      n_donors = ncol(storegaps)-1,
      reduction = decrease,
      file = file,
      sim = f,
      gap_post = avg_gap_post,
      rmspe_pre = perm_results$rmspe_pre[perm_results$laestab == uid_treated],
      rmspe_post = perm_results$rmspe_post[perm_results$laestab == uid_treated],
      rmspe_ratio = perm_results$ratio[perm_results$laestab == uid_treated],
      cutoff_value = cutoff_value,
      prob = prob,
      sig = sig,
      n_ill = n_ill,
      cutoff_thresh5 = cutoff_thresh5,
      prob_thresh5 = prob_thresh5,
      sig_thresh5 = sig_thresh5
    )
    
    if (f == 1 & decrease == 0) {
      df_sim <- sim
    } else {
      df_sim <- rbind(df_sim, sim)
    }
    
  }
  
}

```

```{r power, eval=FALSE, include=F}
# add decrease in percent
df_sim$decrease = factor(paste0(df_sim$reduction * 100, "%"), levels = paste0(0:10, "%"))

# get counts and power obtained across all simulations for this setting #
power <- df_sim %>% 
  group_by(decrease) %>% 
  summarise(
    n_ill = mean(n_ill),
    n_sig = sum(sig_thresh5),
    power_num = 100 * sum(sig_thresh5)/n(),
    power = paste0(power_num, "%")
  )

row_idx <- which(power$power_num > 80) 
  
# compute descriptive stats
vars_to_check <- c("gap_post", "rmspe_pre", "rmspe_post", "rmspe_ratio", "cutoff_value")

out <- 
  # compute descriptive stats
  rbind(
    do.call("rbind", psych::describeBy(df_sim[, vars_to_check], group = df_sim[, "decrease"]))
  ) %>%
  # add decrease and vars from row.names, round values and ensure that they all have two digits
  mutate(
    decrease = sub("%.*", "%", row.names(.)),
    vars = sub(".*%.", "", row.names(.)),
    across(where(is.numeric), ~ round(.x, digits = 2)),
    across(where(is.numeric), ~ sprintf("%.2f", .x))
  ) %>%
  # make decrease factor and create summary string
    mutate(
    decrease = factor(decrease, levels = paste0(0:10, "%")),
    vars = factor(vars, levels = vars_to_check),
    summary = paste0(mean, " (", sd, ") ", "[", min, ";", max, "]")
  ) %>%
  # drop vars and arrange columns
  select(vars, decrease, summary) %>%
  relocate(vars, decrease) %>%
  arrange(vars, decrease) %>%
  tibble::remove_rownames(.) %>%
  # make data wide
  tidyr::pivot_wider(names_from = vars, values_from = summary) %>%
  # merge with counts and power obtained
  as.data.frame()

# print to markdown
full_join(power, out) %>%
  select(-power_num) %>%
  kbl(row.names = F, digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), fixed_thead = T) %>%
  row_spec(row_idx, bold = T) %>%
  print()
  

# plot results of all simulations #

# faceted histogram
plt <- ggplot(data = df_sim) +
  geom_histogram(aes(x = prob_thresh5, fill = sig_thresh5), binwidth = 0.01, boundary = 0, colour = "black", position = "identity") +
  facet_wrap(vars(decrease), ncol = 2, strip.position = "right") +
  ambition_theme +
  theme(axis.title = element_blank(), 
        strip.text = element_text(size = 10, face = "bold"),
        axis.text = element_text(size = 10), 
        legend.position = "none") +
  scale_fill_manual(values = c("TRUE" = coral, "FALSE" = navy40)) +
  geom_text(data = df_sim %>% filter(sig_thresh5 == TRUE) %>% group_by(decrease) %>% summarise(count = n()), 
            aes(x = Inf, y = Inf, label = paste(count, "simulations below 0.05")),
            hjust = 1.1, vjust = 1.1, size = 4, colour = coral)
print(plt)
cat("\n\n")

# scatter plot of probability and effect size
plt <- ggplot(data = df_sim) +
  geom_vline(xintercept = 0.05, linetype = "dashed") +
  geom_point(aes(x = prob_thresh5, y = gap_post, col = sig_thresh5)) +
  facet_wrap(vars(decrease), ncol = 2, strip.position = "right") +
  ambition_theme +
  theme(axis.title.x = element_blank(), 
        strip.text = element_text(size = 10, face = "bold"),
        axis.text = element_text(size = 10), 
        legend.position = "none") +
  ylab("Average treatment effect (treated - synth)") +
  scale_colour_manual(values = c("TRUE" = coral, "FALSE" = navy40)) +
  geom_text(data = df_sim %>% filter(sig_thresh5 == TRUE) %>% group_by(decrease) %>% summarise(count = n()), 
            aes(x = Inf, y = Inf, label = paste(count, "simulations below 0.05")),
            hjust = 1.1, vjust = 1.1, size = 4, colour = coral)
print(plt)
cat("\n\n")

# scatter plot of probability and effect size
plt <- ggplot(data = df_sim) +
  geom_vline(xintercept = 0.05, linetype = "dashed") +
  geom_point(aes(x = prob_thresh5, y = gap_post/pooled_sd, col = sig_thresh5)) +
  facet_wrap(vars(decrease), ncol = 2, strip.position = "left") +
  ambition_theme +
  theme(axis.title.x = element_blank(), 
        strip.text = element_text(size = 10, face = "bold"),
        axis.text = element_text(size = 10), 
        legend.position = "none") +
  scale_colour_manual(values = c("TRUE" = coral, "FALSE" = navy40)) +
  geom_text(data = df_sim %>% filter(sig_thresh5 == TRUE) %>% group_by(decrease) %>% summarise(count = n()), 
            aes(x = Inf, y = Inf, label = paste(count, "simulations below 0.05")),
            hjust = 1.1, vjust = 1.1, size = 4, colour = coral) + 
  scale_y_continuous(
    "Eff (abs) = mean(treated â€“ synth)", 
    sec.axis = sec_axis(~ . / pooled_sd, name = "Eff (pooled SD) = Eff (abs) / pooled national SD ")
  )
print(plt)
cat("\n\n")

# scatter plot of probability and effect size
plt <- ggplot(data = df_sim) +
  geom_vline(xintercept = 0.05, linetype = "dashed") +
  geom_point(aes(x = prob_thresh5, y = gap_post/pooled_sd, col = sig_thresh5)) +
  facet_wrap(vars(decrease), ncol = 2, strip.position = "left") +
  ambition_theme +
  theme(axis.title.x = element_blank(), 
        strip.text = element_text(size = 10, face = "bold"),
        axis.text = element_text(size = 10), 
        legend.position = "none") +
  scale_colour_manual(values = c("TRUE" = coral, "FALSE" = navy40)) +
  geom_text(data = df_sim %>% filter(sig_thresh5 == TRUE) %>% group_by(decrease) %>% summarise(count = n()), 
            aes(x = Inf, y = Inf, label = paste(count, "simulations below 0.05")),
            hjust = 1.1, vjust = 1.1, size = 4, colour = coral) + 
  scale_y_continuous(
    paste0("Change in ratio where 0 equals ", round(starting_ratio, 2)), 
    sec.axis = sec_axis(~ calculate_change_in_teachers(starting_ratio, ., num_pupils), name = paste0("Change in teacher FTE where 0 equals ", round(num_teach, 2)))
  )
print(plt)
cat("\n\n")

# scatter plot of probability and ratio
plt <- ggplot(data = df_sim) +
  geom_vline(xintercept = 0.05, linetype = "dashed") +
  geom_point(aes(x = prob_thresh5, y = rmspe_ratio, col = sig_thresh5)) +
  facet_wrap(vars(decrease), ncol = 2, strip.position = "right") +
  ambition_theme +
  theme(axis.title.x = element_blank(), 
        strip.text = element_text(size = 10, face = "bold"),
        axis.text = element_text(size = 10), 
        legend.position = "none") +
  ylab("Ratio of RMSPE (post) to RMSPE (pre)") +
  scale_colour_manual(values = c("TRUE" = coral, "FALSE" = navy40)) +
  geom_text(data = df_sim %>% filter(sig_thresh5 == TRUE) %>% group_by(decrease) %>% summarise(count = n()), 
            aes(x = Inf, y = Inf, label = paste(count, "simulations below 0.05")),
            hjust = 1.1, vjust = 1.1, size = 4, colour = coral)
print(plt)
cat("\n\n")


# determine output filename
file_name <- file.path(dir, "03_scm_mat", "interim", paste0(file_stem, "_" , tolower(phase), "_it_", sprintf("%03d", ii), ".csv"))
# df_sim <- read.csv(file_name)
# save output
write.csv(df_sim, file = file_name, row.names = FALSE)

```

```{r run_code, echo=F, message=FALSE, results='asis'}
### Process data ###

# Set options for data preparation
id.var <- "group_uid" # ID variable
time.var <- "time_period" # Time variable
outcome.var <- "pupil_to_qual_teacher_ratio" # Dependent variable

w.constr <- list(name = "simplex") # use canonical SC

# default options
target_regions <- c("Yorkshire and the Humber", "North West")
min.years.obs <- 8

#### RUN PERMUTATION IN LOOP ####

# specify increments for decrease
increments <- seq(0, .1, 0.02)


#### SIMULATE DATA IN LOOP ####
# define phases to loop through
phases <- c("mixed", "Secondary", "Primary")
phases <- c("mixed")

headings <- c("Whole MAT", "Secondary schools only", "Primary schools only")
p = 1 # debug
s = 1
k = 5

period.pre <- 2010:2023
period.post <- 2024:2026

for (p in 1:length(phases)) {
  
  cat("# ", headings[p], "\n\n")
  
  phase = phases[p]
  
# get grid search results
<<proc grid>>
  
  # define different filter option for each phase #
  
  if (phase == "mixed") {
    filter_phase = c("Not applicable", "16 plus")
    it <- c(197, 217, 277, 237, 297)
  } else if (phase == "Secondary") {
    filter_phase = unique(groups$phaseofeducation_name)[!grepl("econdary", unique(groups$phaseofeducation_name))]
  } else if (phase == "Primary") {
    filter_phase = unique(groups$phaseofeducation_name)[!grepl("imary", unique(groups$phaseofeducation_name))]
  }
  
  ii = it[1] # debug
  
  # loop through years available
  for (y in 1:length(unique(results_fit$period.pre))) {
    
    years <- unique(as.character(results_fit$period.pre))[y]
    
    
    if (nrow(results_fit[results_fit$period.pre == years & results_fit$it %in% it, ]) > 0) {
      
      cat("## Pre-treatment timeseries", years, "\n\n")
      
      # identify the iterations for this TS
      it_tmp <- results_fit$it[results_fit$period.pre == years & results_fit$it %in% it]

      # loop through the iterations in this TS
      for (ii in it_tmp) {
    
        cat("### Settings", ii, "\n\n")
        
        # select params
        params_out <- results_fit[results_fit$it == ii & !results_fit$cross.val, ]
        
        # show params in markdown
        out_params <- params_out %>%
          mutate(
            pretreat = paste0(min_year, ":", max_year)
          ) %>%
          select(it, pretreat, feat_dv, adj, phase, min.schools.per.timeperiod, min.schools.per.mat, 
                 n_pool, n_active,
                 sd_all, rmspe_all, rmspe_T, rmspe_V, ratio#, m_gap, sd_gap, min_gap, max_gap
          ) %>%
          rename("S/Y" = min.schools.per.timeperiod, "S/M" = min.schools.per.mat)
        
        # print #
        kbl(out_params, row.names = F, digits = 3) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), fixed_thead = T) %>% 
          print()
        cat("\n\n")
        
        
        
        # process data at MAT level
        
        # select params
        params <- results[results$it == ii & !results$cross.val, ]
        
        process_data_scm_mat(uid_treated = uid_treated, target_regions = target_regions, filter_phase = filter_phase,
                             swf_filter = params$swf.filter, 
                             min_years_obs = min.years.obs, 
                             min_schools_per_timeperiod = params$min.schools.per.timeperiod, min_schools_per_mat = params$min.schools.per.mat)
        
        # Apply more filtering
        if (params$exclude.single.phase) {
          # remove MATs from MATs
          MATs$multiple_phases <- grepl(" | ", MATs$phase, fixed = T)
          MATs <- MATs[MATs$multiple_phases, ]
          # remove average MAT ts
          df_avg <- df_avg[df_avg$group_uid %in% MATs$group_uid, ]
          # remove school TS
          df <- df[df$group_uid %in% MATs$group_uid, ]
        }
        
        # show MAT level Y-o-Y changes in outcome
        swf %>% filter(laestab %in% df$laestab[df$group_uid == uid_treated]) %>%
          select(laestab, time_period, pupils_fte, qualified_teachers_fte, pupil_to_qual_teacher_ratio) %>%
          group_by(laestab, time_period) %>%
          group_by(time_period) %>%
          summarise(
            schools = sum(!is.na(pupil_to_qual_teacher_ratio)),
            pupils_fte = mean(pupils_fte, na.rm = T),
            qualified_teachers_fte = mean(qualified_teachers_fte, na.rm = T),
            pupil_to_qual_teacher_ratio = mean(pupil_to_qual_teacher_ratio, na.rm = T)
          ) %>%
          mutate(
            ratio_change = pupil_to_qual_teacher_ratio - lag(pupil_to_qual_teacher_ratio, default = pupil_to_qual_teacher_ratio[1]),
            teacher_fte_change = qualified_teachers_fte - lag(qualified_teachers_fte, default = qualified_teachers_fte[1]),
            pupils_fte_change = pupils_fte - lag(pupils_fte, default = pupils_fte[1])
          ) %>%
          kbl(row.names = F, digits = 2) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), fixed_thead = T) %>%
          print()
        
        # prepare data and estimate scm
        cat("#### SCM for pre-treatment data \n\n")
        <<est>>
          # inspect results
          <<res>>
          
          
          for (k in 1:length(increments)) {
            
            decrease = increments[k]

            # process all simulations
            <<sims>>
          }
        
        # determine output filename
        file_name <- file.path(dir, "03_scm_mat", "interim", paste0(file_stem, "_" , tolower(phase), "_it_", sprintf("%03d", ii), ".csv"))
        # df_sim <- read.csv(file_name)
        # save output
        write.csv(df_sim, file = file_name, row.names = FALSE)
        
        
        # show outputc
        cat("#### Power simulations \n\n")
        # result of power simulations
        <<power>>
          
  }
      
    }

  }

  
  
}
```
